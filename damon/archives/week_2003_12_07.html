<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>damon's notepad: December 07, 2003 - December 13, 2003 彙整</title>

<link rel="stylesheet" href="http://blog.linux.org.tw/~damon/styles-site.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://blog.linux.org.tw/~damon/index.rdf" />
<link rel="start" href="http://blog.linux.org.tw/~damon/" title="Home" />
<link rel="prev" href="http://blog.linux.org.tw/~damon/archives/week_2003_11_30.html" title="November 30, 2003 - December 06, 2003" />

<link rel="next" href="http://blog.linux.org.tw/~damon/archives/week_2003_12_14.html" title="December 14, 2003 - December 20, 2003" />


<script language="javascript" type="text/javascript">
function OpenComments (c) {
    window.open(c,
                    'comments',
                    'width=480,height=480,scrollbars=yes,status=yes');
}

function OpenTrackback (c) {
    window.open(c,
                    'trackback',
                    'width=480,height=480,scrollbars=yes,status=yes');
}
</script>

</head>

<body>	

<div id="banner">
<h1><a href="http://blog.linux.org.tw/~damon/" accesskey="1">damon's notepad</a></h1>
<span class="description"></span>
</div>

<div id="container">

<div class="blog">

<div id="menu">
<a href="http://blog.linux.org.tw/~damon/archives/week_2003_11_30.html">&laquo; November 30, 2003 - December 06, 2003</a> |

<a href="http://blog.linux.org.tw/~damon/">回到主頁面</a>
| <a href="http://blog.linux.org.tw/~damon/archives/week_2003_12_14.html">December 14, 2003 - December 20, 2003 &raquo;</a>

</div>

</div>

<div class="blog">


<h2 class="date">December 11, 2003</h2>


<div class="blogbody">
<a name="000537"></a>
<h3 class="title">Tuning FreeBSD for different applications</h3>

<p>A guide to server and workstation optimization, by Avleen Vig</p>

<p>Server and workstation tuning is an ongoing process.<br />
Believing that you are done only means that you don't know what else can be tuned.</p>

<p>This article should apply equally to FreeBSD 4.x and 5.x</p>

<p>The method of tuning your system is heavily dependent on its function:</p>

<p>    * Will the system perform a lot of small network transactions?<br />
    * Or a small number of large transactions?<br />
    * How will disk operations factor in?</p>

<p>How you answer these and other questions determines what you need to do to improve the performance of your system.<br />
There are several steps you can take before you need to start changing sysctls or re-arranging your partitions. How your applications are compiled plays a major role too. Beyond application compilation we will look at tuning the various other parts of our system including the network, disks, and other system control functions. I have tried not to duplicate the data in the tuning(7) man page, which already contains a wealth of good information on the basics of system performance tuning.<br />
Optimizing software compiling</p>

<p>When source code is compiled, your compiler makes assumptions about your hardware in order to create compatible binaries. If you have an x86-complient CPU for example, your compiler will by default create binaries which can be run on any CPU from a 386 onwards. While this allows portability, any new abilities your CPU advantage of (MMX, SSE, SSE2, 3DNow!, etc) will not be used. So portability creates inefficiency. This is also why using pre-compiled binaies on your system is a sure fire way to reduce your overall performance!</p>

<p>System tuning is best performed on a new system, before many packages are installed. The steps you take here will also effect any new software you install. We assume that your packages are installed from the ports collection (/usr/ports). These steps should be applicable to any other software compiles and we will cover that later in this paper.</p>

<p>The first step to making sure your ports software will be compiled effeciently is to have good compiler flags set up. These are defined in /etc/make.conf. This file does not exist on new systems, but you can copy /etc/defaults/make.conf to /etc/make.conf.<br />
Edit the file, and look for the line starting: #CPUTYPE=<br />
Valid options for the CPUTYPE are listed in the file, in the paragraph above this line. My server is a P233/MMX, and my CPUTYPE line looks like: CPUTYPE=i586/mmx<br />
What this does: The CPUTYPE option notifies the compiler of any special features your CPU has. The compiler will then, where possible, compile code to take advantage of these features. The disadvantage to this is that your compiled binaries may not run on different CPU types. As long as you aren't copying binaries from one server to another, this should not be a problem.</p>

<p>Also in the file, look for the line: #CFLAGS= -O -pipe<br />
Uncomment this line, and change it to: CFLAGS= -O2 -pipe -funroll-loops<br />
What this does: The '-O2' flag sets the optimization level. GCC has the following possible optimization levels:</p>

<p>    * -O: Some opimizations are enabled such as '-fthread-jumps' and '-fdefer-pop'<br />
    * -O2: All optimizations which do not cause the size of the resulting executable to increase are turned on. This is useful for a speed/space tradeoff<br />
    * -O3: Optimize even more. This option may cause the size of your bianries to increase<br />
    * -Os: Optimize for size. Perform most of the optimizations in -O2 and some which reduce the code size</p>

<p>The '-pipe' option decreases the amount of time taken to compile software. When two compiler processes need to communicate data between each other, they can use files on the disk or pipes. As pipes do not require writing anything to disk they can significantly decrease the amount of time taken here.<br />
Finally, '-funroll-loops' causes finite loops to be "unrolled". When a binary compiled with this option is run, the CPU does not have to run through every possible itteration of the loop to get its result. Instead, loops are replaces with with their equivilent non-looping code. This saves one CPU register which would otherwise be tied up in tracking the itteration of the loop.<br />
The gcc man page (man gcc) is a good resource for this.</p>

<p>Warning: It has been noted that for some users on FreeBSD 4.8 and 4.9, the -funroll-loops causes SSHv2 with the base OpenSSH to break. Installing the OpenSSH-portable port to overwrite the base install fixes this problem quickly and easily, and provides a newer version of OpenSSH:</p>

<p>    * cd /usr/ports/security/openssh-portable && \<br />
      make install -DOPENSSH_OVERWRITE_BASE</p>

<p>The make.conf file also contains a line for CXXFLAGS. These options are similar to our CFLAGS options but are used for C++ code. If you are going to compile C++ code, you should take a look at this also.<br />
Optimizing kernel compiling</p>

<p>Efficient kernel compiling is covered in my Kernel Tuning paper at: http://silverwraith.com/papers/freebsd-kernel.php<br />
Optimizing network performance</p>

<p>How you optimize your system for networking depends on what your system will be doing. Below we will take a look at two common applications for servers, Mail and File serving.<br />
Network throughput:</p>

<p>There are a number of steps which can be applied to all installations to improve network performance, and should be done by everyone.</p>

<p>Most modern network cards and switches, support the ability to auto-negotiate the speed to communicate at. While this reduces administration is, it comes at the cost of network throughput. If your switch, server or workstation is set to use auto-negotiation, every few moments it stops transferring network traffic in order to renegotiate its speed. On low-bandwidth use networks this performance degradation might be hard to spot, but on high-bandwidth use networks it become very obvious: You have packet loss, you cannot achieve your full line speed, and your CPU usage is low. I would recommend that everyone read the man page on their network driver and manually define the network speed. This should if possible, also be done on the network switch. Some simple $10 switches do not have interfaces to which you can log in to set this, but fortunately they usually do not renegotiate the network speed after the cable is plugged in, unless the network link is lost.<br />
The network speed can either be set with ifconfig at run time, or in /etc/rc.conf for boot time. Here are two examples for /etc/rc.conf for the rl(4) and fxp(4) network drivers:</p>

<p>    * ifconfig_rl0="inet x.x.x.x netmask x.x.x.x media 100baseTX mediaopt full-duplex"<br />
    * ifconfig_fxp0="inet x.x.x.x netmask x.x.x.x media 100BaseTX mediaopt full-duplex"</p>

<p>If you are fortunate enough to have one of the following network cards:</p>

<p>    * dc -- DEC/Intel 21143 and clone 10/100 ethernet driver<br />
    * fxp -- Intel EtherExpress Pro/100B ethernet device driver<br />
    * rl -- RealTek 8129/8139 fast ethernet device driver<br />
    * sis -- SiS 900, SiS 7016 and NS DP83815 fast ethernet device driver</p>

<p>Note: If your card isn't listed here, do not give up hope! More drivers are being converted as demand comes in and you should look at the documentation for your driver to see if it is supported. If you're still unsure, join the freebsd-questions@freebsd.org mailing list from http://lists.freebsd.org/mailman/listinfo and ask there.</p>

<p>You can enable DEVICE_POLLING in your kernel. DEVICE_POLLING changes the method through which data gets from your network card to the kernel. Traditionally, each time the network card needs attention (for example when it receives a packet), it generates an interrupt request. The request causes a context switch and a call to an interrupt handler. A context switch is when the CPU and kernel have to switch from user land (the user's programs or daemons), and kernel land (dealing with device drivers, hardware, and other kernel-bound tasks). The last few years have seen significant improvements in the efficiency of context switching but it is still an extremely expensive operation. Furthermore, the amount of time the system can have to spend when dealing with an interrupt can be almost limitless. It is completely possible for an interrupt to never free the kernel, leaving your machine unresponsive. Those of us unfortunate enough to be on the wrong side of certain Denial of Service attacks will know about this.</p>

<p>The DEVICE_POLLING option changes this behavior. It causes the kernel to poll the network card itself at certain predefined times: at defined intervals, during idle loops, or on clock interrupts. This allows the kernel to decide when it is most efficient to poll a device for updates and for how long, and ultimately results in a significant increase in performance.</p>

<p>If you want to take advantage of DEVICE_POLLING, you need to compile two options in to your kernel:</p>

<p>    * options DEVICE_POLLING<br />
    * options HZ=1000</p>

<p>The first line enables DEVICE_POLLING and the second device slows the clock interrupts to 1000 times per second. The need to apply the second, because in the worst case your network card will be polled on clock ticks. If the clock ticks very fast, you would spend a lot of time polling devices which defeats the purpose here.</p>

<p>Finally we need to change one sysctl to actually enable this feature. You can either enable polling at runtime or at boot. If you want to enable it at boot, add this line to the end of your /etc/sysctl.conf:</p>

<p>    * kern.polling.enable=1</p>

<p>The DEVICE_POLLING option by default does not work with SMP enabled kernels. When the author of the DEVICE_POLLING code initially commited it he admits he was unsure of the benefits of the feature in a multiple-CPU environment, as only one CPU would be doing the polling. Since that time many administrators have found that there is a significant advantage to DEVICE_POLLING even in SMP enabled kernels and that it works with no problems at all. If you are compiling an SMP kernel with DEVICE_POLLING, edit the file: /usr/src/sys/kern/kern_poll.c and remove the following lines:</p>

<p>      #ifdef SMP<br />
      #include "opt_lint.h"<br />
      #ifndef COMPILING_LINT<br />
      #error DEVICE_POLLING is not compatible with SMP<br />
      #endif<br />
      #endif<br />
    </p>

<p>Mail servers:</p>

<p>Mail servers typically have a very large number of network connections, which transfer a small amount of data for a short period of time, before closing the connection. Here is it useful for us to have a large number of small network buffers.<br />
Network buffer clusters are assigned two per connection, one for sending and one for receiving. The size of the buffer dictates how fast data will be able to funnel through the network, and in the event of a network delay how much data will be able to backlog on the server for that connection before there is a problem. Having a network buffer too small means data will be backlogged at the CPU waiting for the network to clear. This causes greater CPU overhead. Having a network buffer too large means that memory is wasted as the buffer will not be used efficiently. Finding this balance is key to tuning.</p>

<p>When we discuss simultaneous network connections, we refer to connections in any network state: SYN_SENT, SYN_RECV, ESTABLISHED, TIME_WAIT, CLOSING, FIN_WAIT, FIN_WAIT_2, etc. Even if the network connection is in an ESTABLISHED state for only a few seconds, it can end up in any of the other states for a long time. I generally find that multiplying the number of ESTABLISHED connections by 8 leaves me with room to breath in the event that I see an abnormally high surge of traffic inbound or outbound. I've come to this number over time through trial and error. So if you expect to have a peak of 128 servers sending you mail, having 2048 network buffer clusters would be good (128 * 2 per connection * 8). Also remember that connections can take up to two full minutes or more to close completely. So if you expect more than 128 mails in any given two minute period, you also need to increase the number to accomodate that.</p>

<p>Another important value to control is the maximum number of sockets. One socket is created per network connection, and one per unix domain socket connection. While remote servers and clients will connect to you on the network, more and more local applications are taking advantage of using unix domain sockets for inter-process communication. There is far less overhead as full TCP packets don't have to be constructed. The speed of unix domain socket communication is also much faster as data does not have to go over the network stack but can instead go almost directly to the application. The number of sockets you'll need depends on what applications will be running. I would recommend start with with same number of network buffers, and then tuning it as appropriate.</p>

<p>You can find out how many network buffer clusters in use with the command netstat -m</p>

<p>You can specify the values you want, at the end of your /boot/loader.conf file as:</p>

<p>    * kern.ipc.nmbclusters=2048<br />
    * kern.ipc.maxsockets=2048</p>

<p>Note: With any performance tuning, it is important to monitor your system after you make your changes. Did you go overboard, or underestimate what you would need? Always check and adjust accordingly. The numbers here might not be the exact ones that you need!<br />
File servers:</p>

<p>Tuning the network for file servers is not unlike tuning mail servers. The main differences are:</p>

<p>    * File servers generally have longer-lived network connections<br />
    * File servers usually transfer larger files than mail servers<br />
    * File servers mostly perform less transfers than mail servers</p>

<p>Again we come back to network buffer clusters. How many clients do you have? With file servers the chances of a spike in the number of connections is small, as the number of clients is fixed. Therefore we do not need to set aside large numbers of buffers to accommodate spikes. Multiplying the number of network buffers by two is good practice, and some admins prefer to multiply by four to accommodate multiple file transfers.</p>

<p>So if we have 128 clients connecting to the file server, we would set the number of network buffer clusters to 1024 (128 * 2 per connection * 4) in /boot/loader.conf:</p>

<p>    * kern.ipc.nmbclusters=1024<br />
    * kern.ipc.maxsockets=1024</p>

<p>Note: With any performance tuning, it is important to monitor your system after you make your changes. Did you go overboard, or underestimate what you would need? Always check and adjust accordingly. The numbers here might not be the exact ones that you need!<br />
Web servers:</p>

<p>Web servers are not unlike mail servers. Unless you are doing a lot of file serving over the Internet, you will have clients connecting to you for short periods of time. If you have more than one element on your web page, for example multiple images or frames, you can expect that the web browsers of clients will make multiple connections to you. Up to four connections per page served are certainly not uncommon. Also if your web pages use server-side scripting to connect to databases or other servers, you need to add a network connection for each of those.</p>

<p>Web servers again like mail servers, go through periods of highs and lows. While on average you might servers 100 pages a minute, at your low you might server 10 pages a minute and at peak over 1000 pages a minute. Whether you have 128Mb RAM, or 1Gb RAM, you should try and be as liberal as possible in allocating memory to your network stack. Using the above example, at a peak of 1000 pages per minute, your clusters and sockets should be around 16384 (1000 pages * 2 per connection * 4 connections * 2 for growth) in /boot/loader.conf:</p>

<p>    * kern.ipc.nmbclusters=16384<br />
    * kern.ipc.maxsockets=16384</p>

<p>Tuning your Apache or other web servers is slightly outside the scope of this paper, as there is already a ton of excellent data availible on the internet which I could never hope to do justice in this paper. A starting point I would recommend is Aleksey Tsalolikhin's notes from his Nov 2001 presentation to the Unix Users Association of Sothern California on web server performance tuning: http://www.bolthole.com/uuala/webtuning.txt, it should lead you on to more wonderful things.</p>

<p>Note: With any performance tuning, it is important to monitor your system after you make your changes. Did you go overboard, or underestimate what you would need? Always check and adjust accordingly. The numbers here might not be the exact ones that you need!<br />
Optimizing disk usage and throughput</p>

<p>Optimizing the the disk subsystem on FreeBSD also depends on what you want to do with your system. It is very much installation dependent, so what I've done below is list the various factors and what they do. You can decide what is best for you.</p>

<p>   1. RAID:<br />
      RAID is a method of spreading your data over multiple disks. There two reasons why you might use RAID; for redundancy to prevent data loss, and for speed. The three most common types of RAID in use on small system installations are RAID0, RAID1 and RAID1+0 (sometimes referred to as RAID10).<br />
      With RAID1 (also called mirroring), you use only two disks per partition, and keep the data on both disks identical. In the event that one disk is lost, you have your data on another disk. The speed advantage from RAID1 comes when reading. Your system can send multiple read requests to the disks, which will be performed in parallel. The disk whose heads are closest to the requested space will get the request to fetch the data. Writes are no faster than on a single disk. When a write request is sent, both disks must acknowledge that the write has completed before the write is finished.<br />
      RAID0 (also called stripping) spreads the data evenly over two or more disks. Data on one disk is not replicated on the others, so there is no redundancy to prevent data loss. But reads and writes are significantly faster as they happen on multiple disks at the same time. This increases your throughput and your maximum disk operations relative to the number of disks you have. For example, 4 disks would give a 400% increase.<br />
      RAID10 offers the best of both worlds and requires at least 4 disks. Half of the disks are stripped with RAID0, and then both are replicated as a mirror on the remaining disks.<br />
   2. Queue splitting:<br />
      Is you are running a mail server and feel that your system is being slowed because of the speed of your disks, an alternative to RAID could be to split your queues. Most modern mail transfer agents (MTA's) have the ability to break up their large single queue directory into multiple smaller directories. These multiple directories can then be placed on different disks. There are several advantages to this:<br />
          * A disk failure will only take out a half or less of your queue<br />
          * Your throughput on mail will not be disk bound<br />
          * Opening 20 small directories is significantly faster than opening one huge directory<br />
   3. Partitioning:<br />
      Having separate partitions on separate disks can help a lot. For example, your system will always be performing different tasks at any one given time: writing log files, serving out data, and so on. The Unix directory structure is built around using different directories for partitions for different purposes. /usr is traditionally used for user data, /var is used for log and mail spools, etc. Arrange these on different disks to best suit your needs. If you have disks of varying speeds on your system, place the most frequently used partitions on the faster disks.<br />
   4. IDE vs SCSI:<br />
      Back in days of yore (in the early 1990's) when disk performance was crucial, the choice was quite obviously to go for SCSI disks. SCSI provided faster throughput, and less bottle-necking. SCSI disk sizes were significantly larger and more disks could fit in a single system. Times have changed and so have the requirements of most users, and the much sought after disk sizes and faster throughput's are now available on IDE disks. SCSI disk sizes have also grown but not as fast. SCSI disks still offer faster throughput's however. At the time of writing, the fastest IDE disks could push 133Mbyte/s, whereas the fastest SCSI disks could push 320Mbyte/s. </p>

<p>References:</p>

<p>This is a list of references I found when writing this paper. Most of them contain much more detail on their particular subject than I have provided here. Hopefully they will be as useful to you as they were to me.</p>

<p>    * The FreeBSD handbook. A great source on information about FreeBSD. Have a read here if you want to learn something new on FreeBSD<br />
    * Google Groups. I used this extensively to search USENET for articles others may have posted in the past. You should too!<br />
    * htmlhelp.com is made by the Web Design Group to "promote the creation of non-browser specific, non-resolution specific, creative and informative sites that are accessible to all users worldwide." It was valuable in the creation of this site.<br />
</p>


<div class="posted">
	由  發表於 <a href="http://blog.linux.org.tw/~damon/archives/000537.html">10:44 AM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=537" onclick="OpenComments(this.href); return false">迴響 (592)</a>
	
	
</div>

</div>





<div class="blogbody">
<a name="000536"></a>
<h3 class="title">Optimising FreeBSD and it's kernel</h3>

<p>A simple step by step guide, by Avleen Vig</p>

<p>This is a very simple step by step guide on optimising your FreeBSD server or workstation. It doesn't go into a great amount of detail, but after spending several months searching for one source of simple optimisation information and failing, I wrote this paper. All the suggestions listed here are known optimisations available to you if you know where to find them and have the time to do so. There is nothing secret, or special or amazing in this paper, just information on how you can optimise your system.<br />
It can mostly be applied to the other BSDs too, but not Linux. There are plenty of Linux documents out there, so go find one of those. I'm sure there are several HOWTO's. This document is true as of the release of FreeBSD 4.8. Some parts of it, such as optimising your kernel, can also be applied to some previous releases.</p>

<p>Before we proceed any further you should know that as with any system tuning, we have to accept the possibility that something will break. If you're going to recompile the kernel, please read the following URL first. If possible print a copy of the page and keep it with you. It'll help you if your new kernel doesn't boot:<br />
http://www.freebsd.org/handbook/kernelconfig-trouble.html</p>

<p>First we need to make sure we have the right source files downloaded. The best place to start, is the original source files that were intended for the release of FreeBSD you are using. We assume you have a fairly recent release - not more than 2 revisions (approx 6 to 8 months) old. Execute the following command and follow the steps to get the sources needed to recompile a kernel:</p>

<p>    * # /stand/sysinstall<br />
    * Choose 'Configure'<br />
    * Choose 'Distributions'<br />
    * Choose 'src'<br />
    * Choose 'sys' and then choose 'OK', and 'OK' again.<br />
    * Choose an FTP site to download the sources from. If you're prompted to 'skip over the network configuration now', choose 'Yes'. After the install is complete, choose the 'Exit' options until you exit sysinstall.</p>

<p>Congratulations, you now have a know working kernel source tree installed in /usr/src/sys!<br />
Now, cd /usr/src/sys/i386/conf and follow the next steps.</p>

<p>You should see two files in this directory, GENERIC and LINT. These are both kernel configuration files and contain all the data the kernel needs from the user, to compile. They are very easy to read and edit.<br />
GENERIC is the Generic kernel configuration which should work with every system. LINT contains a list of all possible kernel configuration file directives. We won't worry about LINT just yet. First lets trim the GENERIC kernel down and get comfortable with that. Follow these steps to success:</p>

<p>    * Copy the GENERIC file to a new file. Traditionally, this new file has the same name as the hostname of your machine.<br />
    * Edit this new file in your favourite text editor. I prefer vi and have written a cheat sheet for new vi users at:<br />
      http://www.silverwraith.com/papers/vi-quickref.txt<br />
    * There are only a few pitfalls and special cases to watch out for in this file. As you can see it just a plain text file and any line starting with a # is considered a comment and ignored by the compiler.<br />
          o The word 'GENERIC' in the line 'ident GENERIC' is the name of your kernel. This can be any single alphanumeric word with no spaces or punctuation. I recommend you keep it short. Again, it is traditional to name this to be the same as your machine hostname and kernel configuration file name but it is not required. It is informational only.<br />
          o The maxusers line does not actually limit the maximum number of users. It is used internally with an algorithm in the param.c file to determine the sizes and numbers of certain tables. This can remain at the default. As of FreeBSD 4.7 this is set to '0' by default, which causes the actual value to be auto-sized depending on the amount of memory that you have.<br />
          o Most, if not all items in your kernel config will have a comment toward the end of the line. Anything labelled with '[KEEP THIS!]' should not be removed. FreeBSD needs these things! Anything labelled '(required!)' should also be kept if you're going to use that type of device. For example, if you're going to use SCSI devices, don't comment out 'scbus'. If you're not using any SCSI devices, then you should comment this out. Some PCI network cards require the inclusion of 'device miibus'. These are noted in your kernel configuration file. If you don't use these NICs you can also comment this out.<br />
          o Now go through the entire file and comment out anything you don't think you'll need. Effectively every line contains a driver. Commenting it out will mean that particular piece of hardware will not work your system, even though it may be recognised as present in the system. Thus it is bad to comment out your own network card, but good to comment out any cards you don't have. Don't worry if you comment out something you will need later. You can always recompile fairly quickly and simply.<br />
    * After you've finished editing the configuration file, save it and exit from the editor.<br />
    * Issue the command: config <filename> , where <filename> is your configuration file. This only takes a moment and it will tell you which directory is your compile directory. That is where we will compile the kernel. The config command creates the directory structure and files which the next steps use in compiling the kernel.<br />
    * cd to the directory that config gave and issue these commands in turn, each after the previous has finished:<br />
          o # make depend<br />
          o # make<br />
          o # make install<br />
          o Hopefully the above will all work without producing an error. If you get an error, see your local FreeBSD Guru. If you got no error, consider the installation of the new kernel a success!</p>

<p>That is it. Really! If something breaks and your new kernel will not boot, DON'T PANIC! Read the 'Kernel Does Not Boot' section of the URL at the top of the page.<br />
Optimising compiling of code, the kernel<br />
and debugging kernels</p>

<p>This section is for the slightly more advanced compilation of code and kernels. We will also briefly mention how to compile a kernel with the debugging symbols built in. The debugging kernel can be useful when your server or workstation is kernel panicing frequently and you want to find out why. There is a great article from OnLamp.com on how to debug a kernel, available at:<br />
http://www.onlamp.com/pub/a/bsd/2002/04/04/Big_Scary_Daemons.html<br />
Optimising code and kernel compilation</p>

<p>First lets look at optimising the compilation of C code itself. One of the key tasks when doing this is to start with as simple a configuration as possible. Hopefully if you've read everything above you'll be at this stage already :-)</p>

<p>You should set a few specific options in /etc/make.conf that will optimise the compilation of new code on your machine. This means all code will be compiled with these options. If you set the right ones, they can significantly improve the speed and efficiency with which code is compiled and executed. They will also help to reduce memory consumption. If you have installed the portupgrade package from /usr/ports/sysutils/portupgrade, you should execute this command after setting these options and updating your ports collection. It will cause every port you have installed, to have it's latest version downloaded and recompiled with the optimisations. I think it is worth it:</p>

<p>portupgrade -ra</p>

<p>Updating your ports collection en masse can have other consequences which are worth realising. If the current installed version of your port has undergone a major update (eg exim3 to exim4), a straight upgrade in this way could break your configuration. Use with care! The compilation process can take a while, depending on the speed of your CPU, the amount of memory you have, your internet connection and so on, so if you're on a slow link and wish to download the distfiles for each package first and do the updating offline, you can issue this command to download the distfiles for each port first:</p>

<p>portupgrade -Fra</p>

<p>So without further ado, the list of optimisations follows. Initially you won't have an /etc/make.conf, you can just start editing a file with that name (if you want to see every possible option to put in the file, reference /etc/defaults/make.conf):</p>

<p>CPUTYPE=cpu_type<br />
    where cpu_type is one of i386, i486, i586, i586/mmx i686, p2, p3, p4, k6, k6-2, or k7.<br />
    gcc v2, which comes with FreeBSD doesn't yet support the latest Athlon optimisations, so if you<br />
    have a Thunderbird or other such CPU, just set k7 for now. gcc v3 has better support and this<br />
    will be available in FreeBSD 5 when it is released toward the end of 2002.<br />
    NOTE: An important point to remember: Most CPU's of the same family are backward compatible.<br />
    That is, the K7 is backward compatible with K6 code. Also, Intel-CPU code is mostly universally<br />
    compatible across CPU families. However, if you compile code for a non-Intel family CPU type and<br />
    later upgrade to a newer Intel CPU, there is a good chance you may encounter problems unless you<br />
    recompile your code.</p>

<p>CFLAGS= -O3 -pipe -funroll-loops -ffast-math<br />
    -O3 sets optimisation level 3 where the largest number of practical optimisations can be made<br />
    to your code (everything except the kernel). It also does sacrifice binary size for speed.<br />
    -pipe causes code to be passed between processes using pipes during compilation rather than<br />
    using temporary files, which has obvious I/O advantages.<br />
    -funroll-loops causes iterating loops with a known number of iterations to be unrolled into<br />
    faster executions.<br />
    -ffast-math breaks IEEE/ANSI strict math rules. One way it does this is by assuming that the<br />
    square root of numbers are non-negative. This shouldn't be used if you're compiling code that<br />
    relies on the exact implementation of IEEE or ANSI rules for math functions. Unless you're<br />
    writing your own code that does just this you shouldn't have a problem with setting this. It<br />
    should help reduce your compile times.</p>

<p>COPTFLAGS= -O2 -pipe -funroll-loops -ffast-math<br />
    This is the same as the "CFLAGS" statement, except it's used on the kernel when you compile it.<br />
    We choose -O2 instead of -O3, because -O3 is known to produce broken kernels. Officially, only<br />
    -O is supported, but I have never had a problem with -O2. It should be noted at this point that<br />
    one difference between -O2 and -O3 is that -O3 produces slightly larger code during its<br />
    optimising. In normal situations this is OK, but we want to compact the kernel down it is<br />
    another reason to stick with -O2. This also has the same effect as adding the 'makeoptions<br />
    COPTFLAGS' lines to the kernel config as discussed below.</p>

<p>kernel optimisation</p>

<p>In you kernel configuration, add the following line after the 'machine' (i386, i486, etc) types near the top:</p>

<p>makeoptions    COPTFLAGS="-O2 -pipe -funroll-loops -ffast-math"</p>

<p>This does two things. First the -O2 switch tells the compiler to optimise the compilation. This takes advantage of internal compiler tricks to do this. You could use -O3 to implement even more optimisation tricks, but these aren't supported and -O3 is known to cause many stability issues. -O2 may or may not work for you depending on how many things you have compiled into the kernel and how non-standard your hardware is.</p>

<p>TOP_TABLE_SIZE=number<br />
    where number is a prime number, at least twice the number of lines in /etc/passwd.<br />
    This statement sets the size of the hash that the top(1) uses for usernames when it<br />
    runs.</p>

<p>options         CPU_WT_ALLOC</p>

<p>should be set if you have an AMD K5/K6/K6-2 or Cyrix 6x86 chip. It provides for the kernel to enable cache Write Allocation for the L1 cache, which was disabled by default on these chips.</p>

<p>options        NFS_NOSERVER</p>

<p>If you are running a workstation or server when you know that you will not be acting as an NFS server, you can add the above line to your kernel configuration to disable NFS server code. NFS servers allow other servers and workstations to mount parts of their filesystems using the Network FileSystem protocol.</p>

<p>options         NSWAPDEV=number</p>

<p>Another way of saving kernel memory is to define the maximum number of swap devices. Your kernel needs to allocate a fixed amount of bit-mapped memory so that it can interleave swap devices. I set the preceding parameter to 1 on my workstation and 2 on my servers. I rarely run out of swap space on a workstation but if I need to add more to a server, I can easily create another partition<br />
Building a debugging kernel</p>

<p>Another option you have when compiling your kernel is to build with the debugging symbols. This can be fundamental in determining the reason your kernel panics, if it does. Be warned though - compilation time can increase slightly when doing this. To make a debug kernel, add the following line to your kernel configuration:</p>

<p>makeoptions     DEBUG=-g</p>

<p>This doesn't actually install a kernel with full debugging symbols as /kernel. The /kernel that gets installed is the stripped down regular kernel, but a separate kernel.debug file is in /usr/src/sys/compile/Your_Kernel_Name/kernel.debug. If your kernel panics and leaves behind a core file, the kernel.debug file is used to get the debugging symbols when you actually do the debug. See the OnLamp article for more on this.<br />
One final thing you need to do if you're going to be building a debug kernel, is to have your system actually dump the memory to the swap partition. You can do this by adding the following like to /etc/rc.conf and rebooting:</p>

<p>dumpdev="/dev/ad0s1b"</p>

<p>Where "/dev/ad0s1b" is your swap partition as defined in /etc/fstab.<br />
NOTE: Your swap partition needs to be at least 1Mb (1024Kb) bigger than your total amount of memory. When your system crashes, the memory will get dumped to your swap partition. When your system returns, your swap partition will be enabled and your disks will be fsck'd before they are mounted. During this process, fsck uses a small amount of swap space. It would be preferable if you had twice as much swap space as memory in this situation.<br />
References:</p>

<p>This is a list of references I found when writing this paper. Most of them contain much more detail on their particular subject than I have provided here. Hopefully they will be as useful to you as they were to me.</p>

<p>    * OnLamp.com article on debugging FreeBSD kernels. It helped me debug and fix my first kernel.<br />
    * The FreeBSD handbook. A great source on information about FreeBSD. Have a read here if you want to learn something new on FreeBSD<br />
    * Google Groups. I used this extensively to search USENET for articles others may have posted in the past. You should too!<br />
    * htmlhelp.com is made by the Web Design Group to "promote the creation of non-browser specific, non-resolution specific, creative and informative sites that are accessible to all users worldwide." It was valuable in the creation of this site.</p>


<div class="posted">
	由  發表於 <a href="http://blog.linux.org.tw/~damon/archives/000536.html">10:42 AM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=536" onclick="OpenComments(this.href); return false">迴響 (2315)</a>
	
	
</div>

</div>



<h2 class="date">December 10, 2003</h2>


<div class="blogbody">
<a name="000535"></a>
<h3 class="title">blog版面修改完成</h3>

<p>花了一些時間修改成現在的版面，您有興趣的話可以參考看看<br />
把一些在看起來太小的字體放大了，還有一些顏色上的搭配也改了<br />
css檔如下：</p>

<p>	body {<br />
		margin:0px 0px 10px 0px;<br />
		background:#FFFFFF;		<br />
		}<br />
	A 			{ color: #999966; text-decoration: none; font-weight:normal; } <br />
	A:link		{ color: #003366; text-decoration: none; } <br />
	A:visited	{ color: #003366; text-decoration: none; } <br />
	A:active	{ color: #003366;  } <br />
	A:hover		{ color: #003366;  }<br />
	<br />
	h1, h2, h3 {<br />
		margin: 0px;<br />
		padding: 0px;<br />
	}</p>

<p>	#banner {<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#FFF;<br />
		font-size:x-large;<br />
		font-weight:normal;<br />
		border-bottom:1px dotted #FFF;<br />
		border-top:3px solid #99CCFF;<br />
  		background:#336699;<br />
  		padding:15px; <br />
  		text-transform:uppercase;<br />
		letter-spacing: .2em; 		<br />
		}<br />
	<br />
	#banner a,<br />
        #banner a:link,<br />
        #banner a:visited,<br />
        #banner a:active,<br />
        #banner a:hover {<br />
		font-family:verdana, arial, sans-serif;<br />
		font-size: x-large;<br />
		color: #FFF;<br />
		text-decoration: none;<br />
		}</p>

<p>	.description {<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#99CCFF;<br />
		font-size:x-small;<br />
		font-weight:bold;<br />
  		background:#336699;	<br />
  		text-transform:none;	<br />
		letter-spacing: none; 		<br />
		}	<br />
				<br />
	#content {<br />
		float:left;<br />
		width:65%;<br />
		background:#fff;<br />
		border-right:1px dotted #999;<br />
		margin-right:15px;<br />
		padding-bottom:20px;<br />
		}</p>

<p>	#links {<br />
		background:#fff;<br />
		padding-right:15px;	<br />
			<br />
		}<br />
		<br />
	.blog {<br />
  		padding-left:15px;<br />
  		padding-top:15px;<br />
  		padding-right:15px;			<br />
		}	<br />
	<br />
	.blogbody {<br />
		font-family:georgia, verdana, arial, sans-serif;<br />
		color:#666;<br />
		font-size:small;<br />
		font-weight:normal;<br />
  		background:#FFF;<br />
  		line-height:140%;<br />
  		padding-left:10px;	<br />
  		padding-right:10px;<br />
  		padding-top:10px;			<br />
		}</p>

<p><br />
	.blogbody a,<br />
	.blogbody a:link,<br />
	.blogbody a:visited,<br />
	.blogbody a:active,<br />
	.blogbody a:hover {<br />
		font-weight: normal;<br />
		text-decoration: underline;<br />
	}<br />
	<br />
	.title	{ <br />
		font-family: verdana, arial; <br />
		font-size: small; <br />
		color: #003366; <br />
		text-transform: uppercase;<br />
		font-weight:bold;	<br />
		}			<br />
		<br />
	.menu {<br />
  		margin-bottom:15px;<br />
                color: #003366;<br />
		background:#99CCDD;  							<br />
		}	<br />
		<br />
	.date	{ <br />
		font-family:georgia, verdana, arial, sans-serif; <br />
		font-size: small; <br />
		color: #999; <br />
		border:1px solid #999;<br />
		padding:5px;<br />
		margin-bottom:10px;<br />
		font-weight:normal;<br />
		}			<br />
		<br />
	.posted	{ <br />
		font-family:verdana, arial, sans-serif; <br />
		font-size: normal; <br />
		color: #003366;<br />
		margin-bottom:15px; <br />
		}<br />
		<br />
		<br />
	.calendar {<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#AAAAAA;<br />
		font-size:small;<br />
		font-weight:normal;<br />
  		background:#FFF;<br />
  		line-height:140%;<br />
  		padding:2px;<br />
  		text-align:center;	<br />
		}<br />
	<br />
	.calendarhead {	<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#AAAAAA;<br />
		font-size:small;<br />
		font-weight:normal;<br />
  		background:#FFF;<br />
  		line-height:140%;<br />
  		padding:2px;				<br />
		}	<br />
	<br />
	.side {<br />
		font-family:verdana, arial, sans-serif;<br />
                                color:#99CCDD;<br />
                                background:#99CCDD;<br />
		font-size:small;<br />
		font-weight:normal;<br />
  		background:#FFF;<br />
  		line-height:140%;<br />
  		padding:2px;				<br />
		}	<br />
		<br />
	.sidetitle {<br />
		font-family:verdana, arial, sans-serif;<br />
                color:#FFFFFF;<br />
		font-size:small;<br />
		font-weight:normal;<br />
  		background:#99CCDD;<br />
  		line-height:140%;<br />
  		padding:2px;<br />
  		margin-top:10px;<br />
  		text-align:center;<br />
  		text-transform:uppercase;<br />
		letter-spacing: .2em;  					<br />
		}		<br />
	<br />
	.syndicate {<br />
		font-family:verdana, arial, sans-serif;<br />
		font-size:small;<br />
		font-weight:normal;	<br />
                color:#99CCDD;	<br />
                background:#FFFFFF;<br />
  		line-height:140%;<br />
  		padding:2px;<br />
  		margin-top:10px;<br />
  		text-align:center; 		<br />
 		}	<br />
		<br />
	.powered {<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#99CCDD;<br />
                                background:#FFFFFF;<br />
		font-size:small;<br />
		font-weight:normal;<br />
		border-top:1px solid #CCC;<br />
		border-bottom:1px solid #CCC;		<br />
		line-height:140%;<br />
		text-transform:uppercase; <br />
		padding:2px;<br />
		margin-top:10px;<br />
		text-align:center;<br />
		letter-spacing: .2em  					<br />
		}	<br />
		<br />
	<br />
	.comments-body {<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#666;<br />
		font-size:small;<br />
		font-weight:normal;<br />
  		background:#FFF;<br />
  		line-height:140%;<br />
  		padding:10px;			<br />
		}		</p>

<p>	.comments-post {<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#666;<br />
		font-size:x-small;<br />
		font-weight:normal;<br />
  		background:#FFF;			<br />
		}	</p>

<p>	.trackback-body {<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#666;<br />
		font-size:small;<br />
		font-weight:normal;<br />
  		background:#FFF;<br />
  		line-height:140%;<br />
  		padding:10px;			<br />
		}		</p>

<p>	.trackback-url {<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#666;<br />
		font-size:small;<br />
		font-weight:normal;<br />
  		background:#FFF;<br />
  		line-height:140%;<br />
  		padding:10px;<br />
  		border:1px dashed #CCC;			<br />
		}</p>

<p>	.trackback-post {<br />
		font-family:verdana, arial, sans-serif;<br />
		color:#666;<br />
		font-size:x-small;<br />
		font-weight:normal;<br />
  		background:#FFF;			<br />
		}</p>

<p>		<br />
	.comments-head	{ <br />
		font-family: georgia, verdana, arial, sans-serif; <br />
		font-size: small; <br />
		color: #666; <br />
		border:1px solid #999;<br />
		padding:5px;<br />
		font-weight:normal;<br />
		margin-top:10px;		<br />
		}		</p>

<p>	#banner-commentspop {<br />
		font-family:georgia, verdana, arial, sans-serif;<br />
		color:#FFF;<br />
		font-size:large;<br />
		font-weight:bold;<br />
		border-bottom:1px dotted #FFF;<br />
		border-top:3px solid #99CCFF;<br />
  		background:#336699;<br />
  		padding:15px; <br />
		}<br />
</p>


<div class="posted">
	由  發表於 <a href="http://blog.linux.org.tw/~damon/archives/000535.html">09:01 PM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=535" onclick="OpenComments(this.href); return false">迴響 (602)</a>
	
	
</div>

</div>



<h2 class="date">December 09, 2003</h2>


<div class="blogbody">
<a name="000533"></a>
<h3 class="title">The R In R&B Collection, Vol. 1</h3>

<p><img alt="RKELLY_R" src="http://blog.linux.org.tw/~damon/archives/RKELLY_R&B.jpg" width="225" height="224" border="0" /><br />
</p>

<p>我最喜歡的R&B歌手之一R. Kelly推出了個人精選集，不過只有一首新歌，如果以前沒有買過的話，可以考慮買來聽聽看，可是收錄的歌曲有些其實我個人覺得還有更好的可以收錄，應該還有更好的選擇，anyway個人選擇吧<br />
您可以在這邊找到一些試聽的片段(美國版)，雖然大部分都是舊歌<br />
不過要注意的是，台灣版的有多了五首歌，至於是哪五首，我就不查了<br />
http://www.towerrecords.com/product.aspx?pfid=82876552142&from1=BMGRK</p>


<div class="posted">
	由  發表於 <a href="http://blog.linux.org.tw/~damon/archives/000533.html">09:23 PM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=533" onclick="OpenComments(this.href); return false">迴響 (547)</a>
	
	
</div>

</div>



<h2 class="date">December 08, 2003</h2>


<div class="blogbody">
<a name="000532"></a>
<h3 class="title">ArcServe vs CA</h3>

<p>上各星期發mail到CA詢問兩個技術問題<br />
1.一切都照的說明書安裝的oracle agent for linux跟ArcServe v9 for linux為什麼在server端會找不到db<br />
2.ArcServe v9 for linux跑起來之後，大約開了30各port，公司需要透過firewall連線遠端管理，哪些需要開啟，哪些不需要</p>

<p>今天收到回覆了<br />
問題一：只是好聽一點的RTFM<br />
回覆大概如下：<br />
01.please check the oracle service is running<br />
02.please turn the archive log mode on and restart oracle and oracle agent<br />
03.please check if anything wrong in instance.cfg<br />
問題二：大概是他們也不會，或是不想回答，或是OOXX理由，不回就對了</p>

<p>問問題的時候還需要填一些表格，我連我下過哪些指令的log都附上了，結果得到的是RTFM，如果manual上的是有用的，我還需要問嗎？<br />
manual上沒有的東西，直接不答，好樣的</p>

<p>CA的經銷商更神，還附註說：如果都看不到db的話，可能是oracle agent安裝不完整<br />
完整的照的CA偉大的manual安裝的，還附上所下的所有指令，哪裡不完整？</p>

<p>最後決定退貨，47K的oracle agent，卻是這樣的售後服務，如果這輩子我還會考慮使用CA的產品的話，那我一定是瘋了</p>

<p>附帶一題，現在對non free software越來越討厭了，真希望CA這種爛公司，快點倒吧，這些爛工程師，爛客服人員，就讓市場自然淘汰他們吧</p>



<div class="posted">
	由  發表於 <a href="http://blog.linux.org.tw/~damon/archives/000532.html">09:49 PM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=532" onclick="OpenComments(this.href); return false">迴響 (991)</a>
	
	
</div>

</div>



<h2 class="date">December 07, 2003</h2>


<div class="blogbody">
<a name="000530"></a>
<h3 class="title">這一篇是non free software的:(</h3>

<p><a href="http://blog.linux.org.tw/~damon/archives/Screenshot001.html" onclick="window.open('http://blog.linux.org.tw/~damon/archives/Screenshot001.html','popup','width=800,height=600,scrollbars=no,resizable=no,toolbar=no,directories=no,location=no,menubar=no,status=no,left=0,top=0'); return false">View image</a><br />
<a href="http://blog.linux.org.tw/~damon/archives/Screenshot002.html" onclick="window.open('http://blog.linux.org.tw/~damon/archives/Screenshot002.html','popup','width=800,height=600,scrollbars=no,resizable=no,toolbar=no,directories=no,location=no,menubar=no,status=no,left=0,top=0'); return false">View image</a><br />
<a href="http://blog.linux.org.tw/~damon/archives/Screenshot003.html" onclick="window.open('http://blog.linux.org.tw/~damon/archives/Screenshot003.html','popup','width=800,height=600,scrollbars=no,resizable=no,toolbar=no,directories=no,location=no,menubar=no,status=no,left=0,top=0'); return false">View image</a><br />
<a href="http://blog.linux.org.tw/~damon/archives/Screenshot004.html" onclick="window.open('http://blog.linux.org.tw/~damon/archives/Screenshot004.html','popup','width=800,height=600,scrollbars=no,resizable=no,toolbar=no,directories=no,location=no,menubar=no,status=no,left=0,top=0'); return false">View image</a></p>

<p>今天玩一下非常不常玩，大約一年半前滿常玩的遊戲，發現一些有趣的現象XD<br />
從圖中可以看出，在同一個場景下，自己看的到手上的裝備(這東西是交易來的)，但從其他玩家的畫面上卻是手上甚麼都沒有，不過可能是bug，不管他，不太想花時間去研究non free software</p>


<div class="posted">
	由  發表於 <a href="http://blog.linux.org.tw/~damon/archives/000530.html">09:04 PM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=530" onclick="OpenComments(this.href); return false">迴響 (916)</a>
	
	
</div>

</div>





<div class="blogbody">
<a name="000529"></a>
<h3 class="title">Debian unstable update服務恢復</h3>

<p>經過前一陣子被crack的問題發生之後，debian unstable在stable了一段時間之後終於重新online了，有在使用debian unstable的朋友，衝阿<br />
您可以在這邊找到整個被crack的過程與說明，如果您用的是有問題的kernel，儘快更新吧<br />
http://moto.debian.org.tw/viewtopic.php?t=2446</p>



<div class="posted">
	由  發表於 <a href="http://blog.linux.org.tw/~damon/archives/000529.html">07:47 AM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=529" onclick="OpenComments(this.href); return false">迴響 (1174)</a>
	
	
</div>

</div>





<div class="blogbody">
<a name="000528"></a>
<h3 class="title">FreeBSD 5.2 beta available</h3>

<p>經過了長時間的等待，FreeBSD 5.2 release終於快要release了，您可以在這邊找到大約會有那些新功能<br />
http://www.freebsd.org/releases/5.2R/todo.html<br />
至於那時候會出release，您可以到這邊參考看看，不過通常都是會delay，delay多久大概只有天知道XD<br />
http://www.freebsd.org/releases/5.2R/schedule.html<br />
不怕死的FreeBSD愛用者，衝阿<br />
</p>



<div class="posted">
	由  發表於 <a href="http://blog.linux.org.tw/~damon/archives/000528.html">07:39 AM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=528" onclick="OpenComments(this.href); return false">迴響 (2187)</a>
	
	
</div>

</div>


</div>
</div>

</body>
</html>
