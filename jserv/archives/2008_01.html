<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<title>Jserv's blog: January 2008 彙整</title>

<link rel="stylesheet" href="http://blog.linux.org.tw/~jserv/styles-site.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://blog.linux.org.tw/~jserv/index.rdf" />
<link rel="start" href="http://blog.linux.org.tw/~jserv/" title="Home" />
<link rel="prev" href="http://blog.linux.org.tw/~jserv/archives/2007_12.html" title="December 2007" />

<link rel="next" href="http://blog.linux.org.tw/~jserv/archives/2008_02.html" title="February 2008" />


<script language="javascript" type="text/javascript">
function OpenComments (c) {
    window.open(c,
                    'comments',
                    'width=480,height=480,scrollbars=yes,status=yes');
}

function OpenTrackback (c) {
    window.open(c,
                    'trackback',
                    'width=480,height=480,scrollbars=yes,status=yes');
}
</script>

</head>

<body>	

<div id="banner">
<h1><a href="http://blog.linux.org.tw/~jserv/" accesskey="1">Jserv's blog</a></h1>
<span class="description"></span>
</div>

<div id="container">

<div class="blog">

<div id="menu">
<a href="http://blog.linux.org.tw/~jserv/archives/2007_12.html">« December 2007</a> |

<a href="http://blog.linux.org.tw/~jserv/">回到主頁面</a>
| <a href="http://blog.linux.org.tw/~jserv/archives/2008_02.html">February 2008 »</a>

</div>

</div>

<div class="blog">


<h2 class="date">January 26, 2008</h2>


<div class="blogbody">
<a name="001958"></a>
<h3 class="title">「快快樂樂學 GNU Debugger」簡報上線</h3>

今天應 [<a href="http://phorum.study-area.org/">酷！學園</a>] 的邀請，前往台南，給予主題為 [<a href="http://blog.linux.org.tw/~jserv/archives/001951.html">快快樂樂學 GNU Debugger (gdb)</a>] 的演講，感謝雨蒼、鳥哥、崑山科大，以及各位撥空前來指教的朋友們，簡報已上線，可參考 [<a href="http://jserv.sayya.org/debugger/HappyGDB-PartI-2008-01-26.pdf">HappyGDB-PartI-2008-01-26.pdf</a>] 以及對應的範例程式碼 [<a href="http://jserv.sayya.org/debugger/gdb-samples-2008-01-26.tar.bz2">gdb-samples-2008-01-26.tar.bz2</a>]。經過初步的重整，本議程預計拆成三個部份：<ul>
<li>Part I - 概念與初體驗</li>
<li>Part II - 實務與應用探討</li>
<li>Part III - GDB 技巧與整合性技術</li>
</ul>
本次分享的部份是 Part I，提綱如下：<ul>
<li>Debug 類型</li>
<li>Linux 的工具集合</li>
<li>系統提供之偵錯機制</li>
<li>GDB 初體驗</li>
</ul>
希望能讓更多人可善用這些原本躺在硬碟深處的工具 (binutils, gdb, ..)，配合除錯原理概念的建立，得以對系統層面進行尋幽訪勝，並迎刃解決種種技術難題。<br />
<br />
以上，請多指教，謝謝！後續的議程規劃，也在商議中。<br />



<div class="posted">
	由 jserv 發表於 <a href="http://blog.linux.org.tw/~jserv/archives/001958.html">11:30 PM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=1958" onclick="OpenComments(this.href); return false">迴響 (1)</a>
	
	
</div>

</div>



<h2 class="date">January 23, 2008</h2>


<div class="blogbody">
<a name="001957"></a>
<h3 class="title">「Linux 為基礎的嵌入式與即時多工系統」簡報上線</h3>

上週應某單位之邀，給予一份關於 Linux 為基礎的嵌入式
與即時系統的演講，不過因為該單位的性質，所以主要的重心還是擺在 soft/hard Real-time Linux，大綱如下：<ul>
<li>嵌入式平台的思維</li>
<li>解決方案探討分析</li>
<li>Linux 遇上即時系統 :How and Why?</li>
</ul>
除了即時系統概念介紹與 Hard Realtime Linux (RTLinux, RTAI, Xenomai) 外，此次演講對於 Linux kernel 2.6 最近由 Ingo Molnar 整合 TimeSys 與 MontaVista 等重大 real-time 貢獻的 PREEMPT_RT (-RT patchset)，並更新相關的資訊，簡報檔已上線，請參考 [<a href="http://jserv.sayya.org/kernel/Embedded-RT-Linux.pdf">Embedded-RT-Linux.pdf</a>]，另外也可搭配參考小弟三年前的簡報 [<a href="http://blog.linux.org.tw/~jserv/archives/001297.html">Approaches to Realtime Linux</a>]，請多指教，謝謝！<br />



<div class="posted">
	由 jserv 發表於 <a href="http://blog.linux.org.tw/~jserv/archives/001957.html">01:16 AM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=1957" onclick="OpenComments(this.href); return false">迴響 (0)</a>
	
	
</div>

</div>



<h2 class="date">January 22, 2008</h2>


<div class="blogbody">
<a name="001956"></a>
<h3 class="title">SunPinYin 引擎改以 CDDL / LGPL 2.1 雙重授權</h3>

去年提過的 [<a href="http://blog.linux.org.tw/~jserv/archives/001927.html">開放原始碼的 SunPinYin 引擎</a>]，是個基於統計語言模型 (statistical language model, SLM) 的智能拼音引擎，當時的授權以 Sun CDDL (Common Development and Distribution License) 發行，現在正式改以 CDDL / LGPL 2.1 雙重授權方式，詳情可見 Yong Sun 兄的 blog [<a href="http://blogs.sun.com/yongsun/entry/we_announced_the_dual_licensing">We announced the dual-licensing of SunPinyin in CDDL and LGPLv2.1</a>] 與 OpenSolaris 官方聲明 [<a href="http://mail.opensolaris.org/pipermail/opensolaris-announce/2008-January/001717.html">Sun is releasing SunPinyin's source code under a dual-licensing scheme of CDDL and LGPLv2.1</a>]<br />
<br />
雖然 Sun Microsystems 有心貢獻此等高品質的程式碼到開發社群，但採用 CDDL 卻讓許多整合應用或實務面遇到了許多困難。比方說，lexicall 兄已經著手研究分析 Sun PinYin 引擎整合到 [<a href="http://chewing.csie.net/">新酷音輸入法</a>] 的可能性，但首先面對的問題就是，授權條款的不相容，而且依據現在的架構設計，是沒得解決的。然而，現在終於有轉機了，Sun 對此採取雙重授權，所以，倘若要整合 SunPinyin 引擎的話，libchewing 仍可保持 LGPL 授權，這的確是非常鼓舞人心的訊息。<br />
<br />
另外，SunPinyin 也被移植到 BeOS/Haiku 作業系統下，詳情可參考 [<a href="http://blogs.sun.com/yongsun/entry/sunpinyin_running_on_beos">SunPinyin running on BeOS!</a>]，所以現在除了 IIIMF 與 SCIM 輸入法框架的支援外，還多了 [<a href="http://etkxx.gro.clinux.org/beapi/InputMethod.html">BeOS/Haiku 的 Input Method Framework</a>]，而且看來可用性都算不錯。<br />



<div class="posted">
	由 jserv 發表於 <a href="http://blog.linux.org.tw/~jserv/archives/001956.html">10:12 AM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=1956" onclick="OpenComments(this.href); return false">迴響 (0)</a>
	
	
</div>

</div>



<h2 class="date">January 21, 2008</h2>


<div class="blogbody">
<a name="001955"></a>
<h3 class="title">「開放源碼的第五項修煉：淺談社群經營與商業應用」簡報上線</h3>

上週應某單位的邀約，給予一份關於經營自由軟體社群並作商業應用的演講，議程簡介如下：<ul class="code" style="margin: 6px;">
管理學大師彼得．聖吉的代表作《第五項修煉》，被譽為廿一世紀的管理聖經，許多美國知名的企業都非常推崇書中的學習型組織概念，而對更加虛無飄渺的自由軟體
/ 開放源碼社群來說，如何經營並拓廣商業應用，已是刻不容緩的議題。本議程以「第五項修煉」的核心價值分析現有自由軟體專案，並以自身經驗歸納其藝術與實務面。
</ul>
議程大綱：<ul>
<li>自由軟體 / 開放源碼本質：處於虛幻與現實的緩衝帶的社群</li>
<li>經營：管理與完全放任的一線之隔</li>
<li>君子愛財取之有道：商業化途徑</li>
</ul>
簡報已上線，可參考 [<a href="http://jserv.sayya.org/writing/FOSS_Community_Business.pdf">FOSS_Community_Business.pdf</a>]，歡迎指教，謝謝！<br />



<div class="posted">
	由 jserv 發表於 <a href="http://blog.linux.org.tw/~jserv/archives/001955.html">03:06 AM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=1955" onclick="OpenComments(this.href); return false">迴響 (3)</a>
	
	
</div>

</div>



<h2 class="date">January 20, 2008</h2>


<div class="blogbody">
<a name="001954"></a>
<h3 class="title">深入理解 Linux 2.6 的 initramfs 機制 (上)</h3>

日前結束一個消費性電子產品的開發工作，稍有心得，試著整理採取 Linux kernel 2.6 initramfs 機制以加速系統開發的經驗，同時也談論對 fast-booting 設計的重要性，順便解決某些像是「kinit/klibc 為何被提出？」等疑難雜症。<br />
<br />
進入主題前，先看看所謂的 booting。相傳在十八世紀，德國 Baron Münchhausen 男爵常誇大吹噓自己的英勇事蹟，其中一項是「拉著自己的頭髮，將自己從受陷的沼澤中提起」，此事後來收錄於德國《吹牛大王歷險記》，則改寫為「用拔靴帶把自己從海中拉起來」，這裡的「拔靴帶」(bootstrap) 指的是長統靴靴筒頂端後方的小環帶，是用以輔助穿長統靴。這種有違物理原理的誇大動作，卻讓不同領域的人們獲得靈感，Robert A. Heinlein 發表於 1941 年的短文〈By His Bootstraps〉收錄典故並給予多種延伸想法；滑鼠發明人 <a href="http://en.wikipedia.org/wiki/Doug_Engelbart">Doug Engelbart</a> 博士甚至在 1989 年以此命名其研究機構「Bootstrap 學院」，並擔任該院主任。在商業上，bootstrapping 則被引申為一種創業模式，也就是初期投入少量的啟動資本，然後在創業過程中主要依靠從客戶得來的銷售收入，形成一個良好的正現金流。在電腦資訊領域，因為開機過程是環環相扣，先透過簡單的程式讀入記憶體，執行後又載入更多磁區、程式碼來執行，直到作業系統完全載入為止，所以開機過程也被稱為 bootstrapping，簡稱 "boot"。<br />
<br />
自 1991 年 Linux 問世以來，資訊技術的應用有了極大的轉變，筆者之前的文章 [<a href="http://blog.linux.org.tw/~jserv/archives/001840.html">探索 Linux bootloader 的佳作</a>] 與 [<a href="http://orzlab.blogspot.com/2007/06/kboot.html">kboot 初探與模擬驗證</a>] 約略提及光是開機本身的設計來說，就有多種衝擊與需求，隨著 Linux 走出個人電腦領域，在嵌入式系統應用上，更是五花八門。本文所探討的 initramfs，衍生自 Linux kernel 的 initrd，理解其設計需求是先行的準備。initrd 字面上的意思就是 "boot loader initialized RAM disk"，換言之，這是一塊特殊的 RAM disk，在載入 Linux kernel 前，由 boot loader 予以初始化，具體動作就是從特定的儲存裝置中載入 initrd 到 RAM 中 (由啟動參數 "initrd=" 指定 image 的實體或邏輯位置)，隨後 linux kernel 被載入並執行時，會優先處理置放 initrd 的記憶體空間，而這個空間基本上也有檔案系統，通常會包含 init 等程式，故可用以掛入某些特別的驅動程式，比方說 SCSI，完成階段性目標後，kernel 會將真正的 root file system 掛載，並執行 /sbin/init 程式。<br />
<br />
話說回來，我們為何需要此等迂迴的開機途徑呢？原因是，root file system (由啟動參數 "root=" 所指定，以下簡稱 rootfs) 所在的儲存裝置很可能極難尋找，比方說 SCSI 裝置就需要複雜且耗時的程序，若用 RAID 系統更是需要看配置情況而定，同樣的問題也發生在 USB storage 上，因為 kernel 得花上更長的等待與配置時間，或說遠端掛載 rootfs，不僅得處理網路裝置的問題，甚至還得考慮相關的伺服器認證、通訊往返時間等議題。更重要的是，我們可在 initrd 放置某些特別的程式，一來作為掛載 rootfs 作準備，比方說硬體初始化、解密、解壓縮等等，二來提示使用者或系統管理員目前的狀態，這對於消費性電子產品來說，有很大的意義。整體來說，如果能增加開機的彈性 (比方說配合簡單的 shell script 即可達成 USB/SCSI 初始化動作，若透過 kernel code 實做，恐怕上百千行是免不掉的)，又能適度降低 kernel image 本身的設計複雜度與空間使用量，採取 initrd 是很不錯的方式，所以幾乎各大 Linux distribution 都有提供 initrd，以解決在不同硬體、不同裝置上開機的技術議題，也能確保一片 CD-ROM/DVD 可裝入多種個人電腦系統，也可支援 [<a href="http://www.bootsplash.org/">bootsplash</a>] 一類顯示開機動畫的程式。<br />
<br />
具體來說，initrd 提供了「兩階段開機」程序。首先，一切都還是在 kernel mode，由 kernel 完成與硬體相關的初始化工作，接著，在適當的時機點，當 kernel 讀取並掛載 initrd 所在記憶體空間的檔案系統後，kernel 首次從 kernel space 切入 user space，以執行存放於 RAM disk 中的 init 程式，當然，這需要完整的執行環境 (比方說 C runtime 或必要的 program loader 等)，另外，也得確定 rootfs 可被 kernel 所找到並正確掛載。待第一階段的 initrd 步入尾聲後，再回到 kernel mode，initrd 所在的記憶體空間也會適度被釋放 (依據組態而定)，這才進入第二階段，也就是執行真正的 rootfs 中的 init 程式。在 Linux kernel 2.4 中，initrd 大致的處理流程如下：(方括號表示主要的執行單元)<ul>
<li>[boot loader] Boot loader 依據預先設定的條件，將 kernel 與 initrd 這兩個 image 載入到 RAM</li>
<li>[boot loader -&gt; kernel] 完成必要的動作後，準備將執行權交給 Linux kernel</li>
<li>[kernel] 進行一系列初始化動作，initrd 所在的記憶體被 kernel 對應為 /dev/initrd 裝置設備，透過 kernel 內部的 decompressor (gzip 解壓縮) 解開該內容並複製到 /dev/ram0 裝置設備上</li>
<li>[kernel] Linux 以 R/W (可讀寫) 模式將 /dev/ram0 掛載為暫時性的 rootfs</li>
<li>[kernel-space -&gt; user-space] kernel 準備執行 /dev/ram0 上的 /linuxrc 程式，並切換執行流程</li>
<li>[user space] /linuxrc 與相關的程式處理特定的操作，比方說準備掛載 rootfs 等</li>
<li>[user-space -&gt; kernel-space] /linuxrc 執行即將完畢，執行權轉交給 kernel</li>
<li>[kernel] Linux 掛載真正的 rootfs 並執行 /sbin/init 程式</li>
<li>[user space] 依據 Linux distribution 規範的流程，執行各式系統與應用程式</li>
</ul>
值得一提的是，以上「兩階段開機」是 initrd 提出的彈性開機流程，在真實的應用中，也可能從未需要掛載真正的 rootfs，換言之，只是把系統當作都在 RAM disk 上運作，或者永遠都在 initrd 所引導執行的 /linuxrc 程序中執行 (注意：kernel 永遠保留 PID=1 作為 init process 識別，而 /linuxrc 執行的 PID 必非為 1)，在許多裝置如智慧型手機，都是行之有年的，不過這不影響我們後續的探討。
<br />
<br />
Linux Kernel 的發展文化就是願意捨棄既有實做，大膽採用新的途徑 (在符合國際規格的前提下)，Linux 2.6 的 initramfs 之所以提出，就是要修正 initrd 的種種技術問題。問題在哪呢？首先，回顧剛剛探討的流程，initrd RAM disk 對 kernel 來說，本身是個真實的 block device，為了建構存放其中的檔案 (最起碼要有 /linuxrc)，通常我們需要 ext2 一類的檔案系統 (建議)。所以，就建構如此的 initrd image 來看，通常會透過 mkfs.ext2 與 losetup (功能："set up and control loop devices") 等工具建立 loopback device 並編修，所以自然需面對以下問題：<ul>
<li>initrd 必須綁定某個檔案系統實做，如 ext2，可是多數的情況下，我們根本不需要在此階段擁有完整的實做</li>
<li>/dev/initrd block device 建構時即有空間限制，維護繁瑣</li>
<li>運作於 initrd 階段，檔案操作實際上是不斷將 /dev/initrd (對應於某段記憶體) 對應到可存取檔案系統的記憶位址，做了不必要的資源消耗</li>
</ul>
Kernel 文件 ( Documentation/filesystems/ramfs-rootfs-initramfs.txt ) 更指出：<ul class="code" style="margin: 6px;">
Another reason ramdisks are semi-obsolete is that the introduction of
loopback devices offered a more flexible and convenient way to create
synthetic block devices, now from files instead of from chunks of memory.
</ul>
基於上述資源使用與效能考量，原本 ramdisk 途徑就被標示為「老舊」，而 initramfs 的提出，則是基於更簡單有效率的 ramfs 與新的處理方式。<br />
<br />
回到 initrd ramdisk，事實上，原本的設計甚至更加浪費記憶體，因為 Linux 在設計上就會盡可能將讀入/寫入自 block device 的檔案或目錄予以 cache，所以，Linux 會自 ramdisk 中複製資料到 page cache 與 dentry cache，如此往返，徒增資源使用的浪費，這一切問題的根源就是將 initrd 以 block device 來操作的本質使然。Linus Torvalds 為此提出一個想法：<ul>
能否將這些 cache 被掛載為檔案系統呢？就在 cache 中保持這些檔案，但不清除這些，直到實際上被刪去或者系統重啟。
</ul>
基於這些想法，Linus Torvalds 實做了 ramfs，隨後在其他核心開發者的改進下，成為 tmpfs，支援寫入 swap 空間與限制記憶體使用量等特徵。而，initramfs 就是建構於 tmpfs 的基礎上。採取此途徑的效益就是，檔案系統可自行調整空間使用量，以符合所需資料儲存的空間，同時，也不再會有重複的 block device 與 cache 資料，因為跟本不需要，更重要的是，這樣的檔案系統實做，其實就只是 cache 機制的延伸，沒有太多新的程式碼，所以系統可保持簡單明暸。以下是對 initrd 與 initramfs 的概念性比較：<br />
<table align="center">
<tr><th></th>
    <th>initrd</th>
    <th>initramfs</th></tr>
<tr><td>Image</td>
    <td>壓縮過的檔案系統 (如 ext2 + gzip)</td>
    <td>封裝過的檔案 (cpio + gzip)</td></tr>
<tr><td>實做途徑</td>
    <td>block device (RAM disk)</td>
    <td>tmpfs</td></tr>
<tr><td>首先執行的程式</td>
    <td>/linuxrc</td>
    <td>/init</td></tr>
<tr><td>掛載<br />rootfs 方式</td>
    <td>將欲載入的 rootfs 掛載於某個目錄，再 pivot_root 切換 rootfs</td>
    <td>使用 switch_root</td></tr>
</table>
<br />
前面的段落已說明這兩者對於記憶體存取與檔案操作的落差，同時也提及實做途徑，接下來的重點是這兩者如何看待真正的 rootfs。如同前述所及，Linux kernel 2.4 中，initrd 可被視為起始參數 "root=" 的先前處理機制，透過一系列的程序，協助 kernel 找到最終的 rootfs，並一舉掛載進系統，不過，過去的設計其實做了一個假設：「真正的 rootfs 所在的裝置是 block device，同時 initrd 絕非是真正的 rootfs」，這也是為何要讓 kernel 在第一次準備切入 user-space 時，是執行 /linuxrc，而非 /init 或 /sbin/init，因為後者的 PID 恆為 1 且不可被 kill (終止)，但前者因為只是過度的存在，隨時仍可被 kill。<br />
<br />
而在 Linux 2.6 引入 initramfs 的設計後，上述彆扭的假設與處理方式就不復存在，不再區隔「真正」的 rootfs 是如何「存在」，也就是一開機，kernel 就執行位於 initramfs 中的 /init，作為 PID=1 的 init process，僅以 switch_root 作 rootfs 的重新定位罷了 (選擇性)。正因為這樣的特性，核心開發者也將 initramfs 的行為稱為 [<a href="http://tree.celinuxforum.org/pubwiki/moin.cgi/EarlyUserSpace">Early User Space</a>]，Jeff Garzik 於 2002 年十一月發表於 lkml 的文章 [<a href="http://lwn.net/Articles/14448/">initramfs merge, part 1 of N</a>] 提到他的願景：<ul class="code" style="margin: 6px;">
The Future.<br />
<br />
Early userspace is going to be merged in a series of evolutionary  
changes, following what I call "The Al Viro model." NO KERNEL BEHAVIOR  
SHOULD CHANGE. [that's for the lkml listeners, not you <g>] "make"  
will continue to simply Do The Right Thing(tm) on all platforms, while  
the kernel image continues to get progressively smaller.
</ul>
核心開發者很喜歡彼此取笑，這裡提到的 [<a href="http://linuxwire.info/category/al-viro/">Al Viro</a>] 是位知名的 kernel hacker，常常為了捍衛核心設計的一致性與許多開發者對立。這意思就是說，藉由 Early userspace 整合到核心設計後，原本很不容易處理的開機模式，比方說 LVM (Linux Volume Manager)、網路開機、特別儲存裝置的開機等，都可交由 user-space 的應用程式專門處理，相對來說，kernel 就不必過度涉入，長遠來說，對於發展的分工、降低系統複雜度，以及提高可性賴度，均有很大的助益。<br />
<br />
基於 initramfs / Early userspace 的想法，核心開發者又思考為何不將過去難以有效維護但又非得存在不可的程式碼，比方說 do_mount 這一類用以實做掛載特定裝置或邏輯儲存設備的功能，全面轉交給 user-space 的程式去執行呢？這樣 kernel 可專心提昇功能或者效能的改進。為此，以 H. Peter Anvin 為首的核心開發者引入 [<a href="http://www.kernel.org/pub/linux/libs/klibc/">klibc</a>] 與 kinit，前者 (至少目標上) 是最小的 C library 實做，用來支持後者所需 (定位與 [<a href="http://www.fefe.de/dietlibc/">dietlibc</a>] 或 [<a href="http://www.uclibc.org/">uclibc</a>] 一類精巧但通用性的 libc 實做不同)，而 kinit 就是將前述原本在核心實做的程式 (很難偵錯且分析的 kernel code) 拉出到 user-space 中，他於 2006 年六月提交的 patch [<a href="http://linux.derkeiler.com/Mailing-Lists/Kernel/2006-06/msg09405.html">kinit: replacement for in-kernel do_mount, ipconfig, nfsroot</a>] 就展現了將不同的檔案系統 (cramfs, ext2, ext3, jfs, lvm2, minixfs, reiserfs, romfs, xfs, ...) 予以掛載 (即 user-space 的 do_mount)、ipconfig (bootp, dhcp)、nfsmount 等等，整合到 kinit 程式中一併處理，kernel image 可因此大幅縮減。<br />
<br />
大致理解 initramfs 的原理與定位後，我們就可以探討實做與相關的細節。筆者的測試環境是 IBM/lenovo X60 筆記型電腦 (Intel Centrino Duo 1.83GHz) 加上 Ubuntu Linux 7.10，進行下述實做過程之前，請先自 [<a href="http://www.kernel.org/">kernel.org</a>] 取得 stable kernel，本文採用 "linux-2.6.22.5"，所需的套件有：<ul>
<li>build-essential</li>
<li>qemu</li>
<li>ruby</li>
</ul>
假設工作目錄為 $HOME/initramfs-workspace，作些準備動作：('$' 開頭表示輸入的指令，以下同)<pre class="code" style="margin: 6px;"> 
$ cd /home/jserv/initramfs-workspace
$ tar jxvf $HOME/sources/linux-2.6.22.5.tar.bz2
$ mkdir -p hello-initramfs
</pre>
首先設立的目標是，可印出 "Hello World" 的 kernel + initramfs，並透過 qemu 進行模擬驗證。首先，建立一個 init.c，具備簡單的實做：<pre class="code" style="margin: 6px;">
$ cd hello-initramfs
$ cat init.c
#include &lt;stdio.h&gt;
int main()
{
	printf("Hello World!\n");
	sleep(99999);
	return 0;
}
$ gcc -static -o init init.c
$ mkdir -p dev
$ sudo mknod dev/console c 5 1
</pre>
建議先試著執行 "./init" 看看是否正確運作，程式碼中的 "sleep(99999)" 只是讓觀察更容易，避免畫面一閃而逝。剛剛的 "Hello World" 程式就是我們預期的 Early userspace，因為執行時期需要 tty (terminal)，所以剛剛也一併建立 /dev/console 的 character device。現在我們可以來準備建構 kernel 了：<pre class="code" style="margin: 6px;">
$ cd /home/jserv/initramfs-workspace/linux-2.6.22.5
$ make menuconfig
</pre>
要注意的是，需將 "General setup" 的子項目 "Initial RAM filesystem and RAM disk (initramfs/initrd) suppot" 打開，並在下方提示 "INITRAMFS_SOURCE" 的畫面輸入我們期望的 initramfs 的來源目錄，也就是 "/home/jserv/initramfs-workspace/hello-initramfs"，參考的配置畫面如下：<br />
<center><img src="http://jserv.sayya.org/kernel/initramfs/pix/menuconfig.png" /></center><br />
也可以參考筆者的組態檔 [<a href="http://jserv.sayya.org/kernel/initramfs/dotconfig">.config</a>]，當然之後就是建構核心：<pre class="code" style="margin: 6px;">
$ make bzImage
...
  LD      arch/i386/boot/compressed/vmlinux
  OBJCOPY arch/i386/boot/vmlinux.bin
  HOSTCC  arch/i386/boot/tools/build
  BUILD   arch/i386/boot/bzImage
Kernel: arch/i386/boot/bzImage is ready
</pre>
建構成功，透過 qemu 來模擬測試：<pre class="code" style="margin: 6px;">
$ qemu -kernel arch/i386/boot/bzImage -hda /dev/zero
</pre>
參考的執行畫面如下：<br />
<center><img src="http://jserv.sayya.org/kernel/initramfs/pix/hello-qemu.png" /></center></br />
所以我們可以發現，在產生出來的 kernel image 中，其實已經包含了剛剛的 initramfs，看來裡頭大有文章。回頭看看編譯的過程：<pre class="code" style="margin: 6px;">
scripts/kconfig/conf -s arch/i386/Kconfig
  CHK     include/linux/version.h
  CHK     include/linux/utsrelease.h
  CC      arch/i386/kernel/asm-offsets.s
  GEN     include/asm-i386/asm-offsets.h
...
  CC      init/initramfs.o
  CC      init/calibrate.o
  LD      init/built-in.o
  HOSTCC  usr/gen_init_cpio
  <b>GEN     usr/initramfs_data.cpio.gz</b>
  AS      usr/initramfs_data.o
...
</pre>
我們可注意到 "GEN usr/initramfs_data.cpio.gz" 這行，勢必 kernel 2.6 中隱含了某種機制，執行看看之前產生的工具程式：<pre class="code" style="margin: 6px;">
$ usr/gen_init_cpio
Usage:
	usr/gen_init_cpio &lt;cpio_list&gt;

&lt;cpio_list&gt; is a file containing newline separated entries that
describe the files to be included in the initramfs archive:
...
</pre>
這裡提到的 "archive" 就是透過 [<a href="http://www.gnu.org/software/cpio/">cpio</a>] 工具產生的封裝檔案，在 RedHat .rpm 或 Debian .deb 均有採用此工具。不過 Linux kernel 則提供一個整合性的工具，可一次處理目錄與檔案的封裝，依據之前的流程試試看手動建立 cpio + gzip：<pre class="code" style="margin: 6px;">
$ cd /home/jserv/initramfs-workspace
$ sudo cp -af hello-initramfs hello2-initramfs
$ cd hello2-initramfs
$ cat init.c 
#include &lt;stdio.h&gt;
int main()
{
	printf("Yat Another Hello World!\n");
	sleep(999999);
	return 0;
}
$ gcc -static -o init init.c
$ cat desc_initramfs
dir /dev 0755 0 0
nod /dev/console 0600 0 0 c 5 1
file /init /home/jserv/initramfs-workspace/hello2-initramfs/init 0755 0 0
$ ../linux-2.6.22.5/usr/gen_init_cpio desc_initramfs &gt; my_initramfs.cpio
$ gzip my_initramfs.cpio
</pre>
"desc_initramfs" 是我們自己寫的描述檔，格式大抵就如上面展示，usr/gen_init_cpio 這個工具則會建構對應的 dir + device node + file 的封裝，最後我們以 gzip 壓縮起來，於是可得到 "my_initramfs.cpio.gz" 這個新的 initramfs image。同樣的，我們可用 qemu 測試驗證，這次改由 qemu 模擬 boot loader 指定 initramfs image 的模式，操作如下：<pre class="code" style="margin: 6px;">
$ cd /home/jserv/initramfs-workspace/linux-2.6.22.5
qemu -kernel arch/i386/boot/bzImage -initrd ../hello2-initramfs/my_initramfs.cpio.gz -hda /dev/zero
</pre>
這次應該就會在 qemu 模擬的輸出畫面最下方看到 "Yat Another Hello World!" 的字樣。<br />
<br />
只有 "Hello World" 一類的程式只能作切入點，還不能實際作點事情，從零到有建構 rootfs 也得花上一點功夫，還好，Ubuntu/Debian 已經提供靜態連結的 [<a href="http://www.busybox.net/">BusyBox</a>]，安裝方式很簡單：<pre class="code" style="margin: 6px;">
$ sudo apt-get install busybox-static
</pre>
隨後，系統會安裝 /bin/busybox 的執行檔，觀察一下：<pre class="code" style="margin: 6px;">
$ file /bin/busybox
/bin/busybox: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for GNU/Linux 2.6.8, statically linked, stripped
</pre>
咱們就以此為基礎，建立一個小而美的 initramfs + kernel image：<pre class="code" style="margin: 6px;">
$ cd /home/jserv/initramfs-workspace
$ mkdir -p busybox-initramfs/bin
$ mkdir -p busybox-initramfs/proc
$ cd busybox-initramfs/bin
$ cp /bin/busybox .
$ ./busybox --help | ruby -e 'STDIN.read.split(/functions:$/m)[1].split(/,/).each{|i|`ln -s busybox #{i.strip}` unless i=~/busybox/}'
$ cd ..
$ echo -e '#!/bin/busybox sh\nmount -t proc proc /proc\nexec busybox sh\n' &gt; init ; chmod +x init
$ find . | cpio -o -H newc | gzip &gt; ../busybox.initramfs.cpio.gz
</pre>
可看到 $HOME/initramfs-workspace 就輸出了名為 busybox.initramfs.cpio.gz 的 initramfs image，可仿造上一個範例，透過 qemu 模擬：<pre class="code" style="margin: 6px;">
$ cd /home/jserv/initramfs-workspace/linux-2.6.22.5
qemu -kernel arch/i386/boot/bzImage -initrd ../busybox.initramfs.cpio.gz -hda /dev/zero
</pre>
參考的執行畫面如下：<br />
<center><img src="http://jserv.sayya.org/kernel/initramfs/pix/busybox-qemu.png" /></center><br />
後續的篇幅，我們會探討實務上如何應用，如 Ubuntu 的 software suspend/resume image 與 fast-booting 整合，以及 kernel 的實做細節。<br />



<div class="posted">
	由 jserv 發表於 <a href="http://blog.linux.org.tw/~jserv/archives/001954.html">11:54 PM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=1954" onclick="OpenComments(this.href); return false">迴響 (18)</a>
	
	
</div>

</div>



<h2 class="date">January 15, 2008</h2>


<div class="blogbody">
<a name="001953"></a>
<h3 class="title">以 GtkWave 作視覺化分析</h3>

評量一個 RTOS 的效能有很多方式，其中有個重點是分析 latency。依據系統性質的不同，我們會探討 interrupt、context switching、critical section 等等事件的具體運作細節，設計良好的 RTOS 應要提供特定的機制，允許作遠端的紀錄與分析，我們可借助 gdb remote debugging 既有的機制，將 commands/responses 序列作定性分析。<br />
<br />
當然，如能視覺化會是更好，可透過發展成熟的 [<a href="http://home.nc.rr.com/gtkwave/">GTKWave</a>] 軟體來協助。GTKWave 是個以 Gtk+ 撰寫的波形瀏覽追蹤工具，能自波形的傅立葉轉換來作分析與視覺化，並支持 Verilog VCD/EVCD 檔案格式，所以上述的 gdb commands/responses 只要能轉化為標準 Verilog VCD 格式，就可作為輸入並視覺化，以 Jamei RTOS i386 開發平台為例，結果如下：<br />
<center><img src="http://jserv.sayya.org/misc/latency-visual.png" /></center><br />
對了，[<a href="http://home.nc.rr.com/gtkwave/">GTKWave</a>] 以 GNU GPL 授權發行。<br />



<div class="posted">
	由 jserv 發表於 <a href="http://blog.linux.org.tw/~jserv/archives/001953.html">06:36 PM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=1953" onclick="OpenComments(this.href); return false">迴響 (0)</a>
	
	
</div>

</div>





<div class="blogbody">
<a name="001952"></a>
<h3 class="title">一萬個重作的理由</h3>

最近又開始閉關作些有趣的專案，在確認經濟條件不虞匱乏後，應可安心作上一段時間。著眼於 [<a href="http://blog.linux.org.tw/~jserv/archives/001950.html">2008 年度計畫</a>]，今年的範疇不再只是基於現有的 free software 作客製化與優化，也有基於對現有架構和設計理念的不滿，另起爐灶的新計畫，比方說，去年提及的 [<a href="http://blog.linux.org.tw/~jserv/archives/001936.html">Jamei RTOS</a>] 就是一例，這幾個月做了大幅翻修，未來可望整合到 RT nanokernel 架構中。<br />
<br />
光是浮上檯面的 RTOS 就好幾十個，更別說那種名不見經傳的項目，至於為什麼要重作呢？在一群 NetBSD hacker 發起的 [<a href="http://chiharu.haun.org/peace/">PEACE</a>] 計畫中，TAMURA Kent 在簡報提到，目標為在 NetBSD 建構執行 Win32 PE 執行檔的環境的 [<a href="http://chiharu.haun.org/peace/">PEACE</a>] 專案，為何不直接採用知名的 [<a href="http://www.winehq.org/">Wine</a>] 呢？他用一句很妙的話回覆：<ul class="code" style="margin: 6px;">
"Existing software don’t prevent us from developing new software for the same purpose."
</ul>
是呀，就是這麼一回事，有不同的理念就去作，何必受限於既有的系統呢？接著，TAMURA Kent 補充兩項：<ul>
<li>It is not bad to exist different implementations.</li>
<li>JUST FOR FUN!  We’re enjoying development.</li>
</ul>
我想，這大概就是「一萬個重作的理由」之首項，尚有九千九百九十九個動人的理由，待我們親身體會，謹此自勉！<br />



<div class="posted">
	由 jserv 發表於 <a href="http://blog.linux.org.tw/~jserv/archives/001952.html">05:30 PM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=1952" onclick="OpenComments(this.href); return false">迴響 (3)</a>
	
	
</div>

</div>



<h2 class="date">January 09, 2008</h2>


<div class="blogbody">
<a name="001951"></a>
<h3 class="title">演講：快快樂樂學 GNU Debugger (gdb)</h3>

應 [<a href="http://phorum.study-area.org/">Study Area</a>] 之邀，月底將在台南分享關於 GNU/Linux 與 toolchain 相關的議題，本次演講主題為「快快樂樂學 GNU Debugger (gdb)」，以下引述討論區訊息 [<a href="http://phorum.study-area.org/index.php?topic=49876.0">2008一月份 SA@Tainan 快快樂樂學 GNU Debugger (gdb)</a>]：<ul class="code" style="margin: 6px;">
<li>簡介：<ul>
兩年前，為了徹底理解 GNU/Linux 底層運作機制，拿最簡單的 "Hello World" 開刀，部份心得匯集為「深入淺出Hello World」，並於北中南等地分享，計有 Part I / II / III。後續的規劃則因為大量使用 gdb / kdb /kgdb 等重要工具，決定以獨立的議程作講解，期望使聽者得以透過 GNU Debugger (gdb)來加速系統開發與分析，讓這個臥在硬碟深處許久的強力程式，激發其威力。本議程捨棄過往教條式的介紹形式，延續「深入淺出 HelloWorld」系列的「作中學」途徑逐一探討使用情境與案例分析。</ul>
</li>

<li>議程主題：<ul>
<li>Why - 為何我們該善用 Debugger？</li>
<li>Who - 誰會因為熟悉 Debugger 而受益？</li>
<li>What - 史上最強大的 Debugger -- gdb 與一系列系統軟體</li>
<li>Where - 利用 Debugger 的場合</li>
<li>How - 還用說嗎？來就對了</li></ul>
</li>

<li>時間：1月26日14:00-17:00</li>

<li>地點：<ul>
<li>台南崑山科技大學 資訊科技大樓 I3502教室; 台南縣永康市大灣路949號</li>
<li>[<a href="http://www.ksu.edu.tw/introduction/GoogleLocation.aspx">地理位置</a>]</li>
<li>[<a href="http://www.ksu.edu.tw/introduction/images/campus_1024.jpg">校園地圖</a>]</li></ul>
</li>

<li>參考資訊：<ul>
<li>[<a href="http://www.eettaiwan.com/ARTP_8800464697_676964.HTM">除錯問題成為眾矢之的</a>]</li>
<li>[<a href="http://sources.redhat.com/gdb/">GDB: The GNU Project Debugger</a>]</li></ul>
</li>

<li>講師特別交代之注意事項：<ul>
<li>本議程基於知識共享之原則，提供免費教育訓練，但僅限於 x86 硬體平台，若有 ARM 與 MIPS 平台需求者，請進一步聯繫講者</li>
<li>礙於講者個人規劃，暫無舉辦台北場次的打算，請見諒</li>
<li>事先提交問題，可優先解決與討論</li>
<li>歡迎招待當地名產，或廣結善緣</li></ul>
</li>
</ul>
本演講的講稿內容及聽眾的 Q&A 將會整理為「精通 GDB :深入 GNU 開發與除錯工具」一文，文章的序言可先行參考 [<a href="http://jserv.sayya.org/writing/mastering-gdb-preface.pdf">mastering-gdb-preface.pdf</a>]，有任何問題也請多利用前述的討論區，期待您的指教，謝謝！<br />



<div class="posted">
	由 jserv 發表於 <a href="http://blog.linux.org.tw/~jserv/archives/001951.html">08:07 AM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=1951" onclick="OpenComments(this.href); return false">迴響 (5)</a>
	
	
</div>

</div>





<div class="blogbody">
<a name="001950"></a>
<h3 class="title">展望 2008</h3>

連續兩日未眠，debug 某個複雜的系統，終於體力透支而休息暫緩，醒來已是夜間。過了二十五歲，生理機能即往下坡，復以如此操勞，很明顯察覺五臟六腑集體罷工的無力感，無奈靈感湧上，又苦苦無予以實現，心有不甘。蹉跎歲月至今，竟然邁入 2008 年，心中甚是惶恐。<br />
<br />
四年前剛上來台北時，手頭有許多專案或產品設計就是著眼於 2008 年。令人欣慰的是，自己直接或間接投入的項目，有幾個正磨刀霍霍，將於今年在市場上現身，想到當年雇主與合作對象皆再三強調產品在 2008 年「卡位」的重要性，而現在正是驗證理念的時機，不過，這也讓我不得不認真思索下一步。想到的第一個大方向大概是離開台北，換言之，相當於改變生活環境與工作模式，為此，必須盡快將手頭的工作結案，該放下的，也得適時放下，之後會逐漸移往中南部。<br />
<br />
第二個方向是進修，不過不是回學校唸書 (時機未到)，主要是硬體設計與電磁輻射相關的範疇，稍早設計機器人時即已面臨種種挑戰，今年應該更努力投入。第三是檢視現有的技術領域：<ul>
<li>RTOS / RT nanokernel</li>
<li>Linux Desktop and Graphics</li>
<li>NetBSD embedded and RT extension</li>
<li>Virtualization / Dynamic Binary Optimization</li>
<li>Platform-based Computing</li>
</ul>
研究的系統新增 NetBSD，一方面是客戶要求，另一方面則是因為 FreeBSD / NetBSD 在 ARM 平台成熟度提高許多，後者甚至能在 [<a href="http://www.openmoko.org/">openmoko</a>] 的硬體上運作，主題仍圍繞在 Embedded 與 Realtime。此外，希望在調整工作步伐後，能將過去的想法集結成技術文件或分享，預定有以下題材：<ul>
<li>「深入淺出 Hello World」系列演講：踏入 kernel 與 application 互動的美妙世界</li>
<li>GNU Toolchain：不只是使用，更要藉此深入 hacking</li>
<li>視訊壓縮技術與 MPEG 系列標準，並討論專利對於自由軟體的衝擊</li>
<li>GPL 與商業化應用</li>
</ul>
最後，台灣雖有不少優秀的技術人才，但往往受制於所謂的「大環境」，做了妥協的結果，就是不斷以單打獨鬥或閉門造車的姿態，忙了一場，只有事倍功半，這幾年有相當強烈的感觸。希望，[<a href="http://orzlab.blogspot.com/">OrzLab</a>] 可以是個起點，至少匯集若干開放的技術，思考現有不足之處，尋求「借力使力」的途徑，如此一來，才能在新世代的技術衝擊下，得以立足。<br />
<br />



<div class="posted">
	由 jserv 發表於 <a href="http://blog.linux.org.tw/~jserv/archives/001950.html">07:48 AM</a>
		| <a href="http://mt.debian.org.tw/mt-yijian.cgi?entry_id=1950" onclick="OpenComments(this.href); return false">迴響 (1)</a>
	
	
</div>

</div>


</div>
</div>

<!-- Site Meter -->
<script type="text/javascript" src="http://s23.sitemeter.com/js/counter.js?site=s23jserv">
</script>
<noscript>
<a href="http://s23.sitemeter.com/stats.asp?site=s23jserv" target="_top">
<img src="http://s23.sitemeter.com/meter.asp?site=s23jserv" alt="Site Meter" border="0"/></a>
</noscript>

</body>
</html>
